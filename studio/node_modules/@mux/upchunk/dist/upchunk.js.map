{"version":3,"sources":["webpack://UpChunk/webpack/universalModuleDefinition","webpack://UpChunk/webpack/bootstrap","webpack://UpChunk/./src/upchunk.ts","webpack://UpChunk/./node_modules/event-target-shim/dist/event-target-shim.js"],"names":["root","factory","exports","module","define","amd","this","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","__assign","assign","arguments","length","apply","event_target_shim_1","SUCCESSFUL_CHUNK_UPLOAD_CODES","TEMPORARY_ERROR_CODES","UpChunk","options","_this","endpoint","file","headers","chunkSize","attempts","delayBeforeAttempt","chunkCount","chunkByteSize","totalChunks","Math","ceil","size","attemptCount","offline","paused","reader","FileReader","eventTarget","EventTarget","validateOptions","getEndpoint","then","sendChunks","window","addEventListener","dispatch","on","eventName","fn","pause","resume","detail","event","CustomEvent","dispatchEvent","TypeError","File","endpointValue","Promise","resolve","getChunk","start","onload","result","chunk","Blob","type","readAsArrayBuffer","slice","sendChunk","rangeStart","rangeEnd","Content-Type","Content-Length","Content-Range","chunkNumber","fetch","method","body","manageRetries","setTimeout","message","attemptsLeft","res","includes","status","percentProgress","round","err","createUpload","privateData","WeakMap","wrappers","pd","retv","console","assert","setCancelFlag","data","passiveListener","cancelable","canceled","preventDefault","error","Event","set","eventPhase","currentTarget","stopped","immediateStopped","timeStamp","Date","now","keys","defineRedirectDescriptor","[object Object]","configurable","defineCallDescriptor","getWrapper","proto","wrapper","BaseEvent","constructor","writable","isFunc","getOwnPropertyDescriptor","defineWrapper","getPrototypeOf","isStopped","setPassiveListener","target","NONE","CAPTURING_PHASE","AT_TARGET","BUBBLING_PHASE","stopPropagation","stopImmediatePropagation","bubbles","Boolean","defaultPrevented","composed","srcElement","cancelBubble","returnValue","setPrototypeOf","listenersMap","ATTRIBUTE","isObject","x","getListeners","listeners","defineEventAttribute","eventTargetPrototype","node","listenerType","listener","next","prev","delete","newNode","passive","once","defineEventAttributeDescriptor","defineCustomEventTarget","eventNames","CustomEventTarget","Array","isArray","types","Map","optionsIsObj","capture","undefined","wrappedEvent","wrapEvent","handleEvent","setEventPhase","setCurrentTarget","default"],"mappings":"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","file":"upchunk.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"UpChunk\"] = factory();\n\telse\n\t\troot[\"UpChunk\"] = factory();\n})(this, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","\"use strict\";\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nexports.__esModule = true;\nvar event_target_shim_1 = require(\"event-target-shim\");\nvar SUCCESSFUL_CHUNK_UPLOAD_CODES = [200, 201, 202, 204, 308];\nvar TEMPORARY_ERROR_CODES = [408, 502, 503, 504]; // These error codes imply a chunk may be retried\nvar UpChunk = /** @class */ (function () {\n    function UpChunk(options) {\n        var _this = this;\n        this.endpoint = options.endpoint;\n        this.file = options.file;\n        this.headers = options.headers || {};\n        this.chunkSize = options.chunkSize || 5120;\n        this.attempts = options.attempts || 5;\n        this.delayBeforeAttempt = options.delayBeforeAttempt || 1;\n        this.chunkCount = 0;\n        this.chunkByteSize = this.chunkSize * 1024;\n        this.totalChunks = Math.ceil(this.file.size / this.chunkByteSize);\n        this.attemptCount = 0;\n        this.offline = false;\n        this.paused = false;\n        this.reader = new FileReader();\n        this.eventTarget = new event_target_shim_1.EventTarget();\n        this.validateOptions();\n        this.getEndpoint().then(function () { return _this.sendChunks(); });\n        // restart sync when back online\n        // trigger events when offline/back online\n        if (typeof (window) !== 'undefined') {\n            window.addEventListener('online', function () {\n                if (!_this.offline) {\n                    return;\n                }\n                _this.offline = false;\n                _this.dispatch('online');\n                _this.sendChunks();\n            });\n            window.addEventListener('offline', function () {\n                _this.offline = true;\n                _this.dispatch('offline');\n            });\n        }\n    }\n    /**\n     * Subscribe to an event\n     */\n    UpChunk.prototype.on = function (eventName, fn) {\n        this.eventTarget.addEventListener(eventName, fn);\n    };\n    UpChunk.prototype.pause = function () {\n        this.paused = true;\n    };\n    UpChunk.prototype.resume = function () {\n        if (this.paused) {\n            this.paused = false;\n            this.sendChunks();\n        }\n    };\n    /**\n     * Dispatch an event\n     */\n    UpChunk.prototype.dispatch = function (eventName, detail) {\n        var event = new CustomEvent(eventName, { detail: detail });\n        this.eventTarget.dispatchEvent(event);\n    };\n    /**\n     * Validate options and throw error if not of the right type\n     */\n    UpChunk.prototype.validateOptions = function () {\n        if (!this.endpoint ||\n            (typeof this.endpoint !== 'function' && typeof this.endpoint !== 'string')) {\n            throw new TypeError('endpoint must be defined as a string or a function that returns a promise');\n        }\n        if (!(this.file instanceof File)) {\n            throw new TypeError('file must be a File object');\n        }\n        if (this.headers && typeof this.headers !== 'object') {\n            throw new TypeError('headers must be null or an object');\n        }\n        if (this.chunkSize &&\n            (typeof this.chunkSize !== 'number' ||\n                this.chunkSize <= 0 ||\n                this.chunkSize % 256 !== 0)) {\n            throw new TypeError('chunkSize must be a positive number in multiples of 256');\n        }\n        if (this.attempts &&\n            (typeof this.attempts !== 'number' || this.attempts <= 0)) {\n            throw new TypeError('retries must be a positive number');\n        }\n        if (this.delayBeforeAttempt &&\n            (typeof this.delayBeforeAttempt !== 'number' ||\n                this.delayBeforeAttempt < 0)) {\n            throw new TypeError('delayBeforeAttempt must be a positive number');\n        }\n    };\n    /**\n     * Endpoint can either be a URL or a function that returns a promise that resolves to a string.\n     */\n    UpChunk.prototype.getEndpoint = function () {\n        var _this = this;\n        if (typeof this.endpoint === 'string') {\n            this.endpointValue = this.endpoint;\n            return Promise.resolve(this.endpoint);\n        }\n        return this.endpoint(this.file).then(function (value) {\n            _this.endpointValue = value;\n            return _this.endpointValue;\n        });\n    };\n    /**\n     * Get portion of the file of x bytes corresponding to chunkSize\n     */\n    UpChunk.prototype.getChunk = function () {\n        var _this = this;\n        return new Promise(function (resolve) {\n            // Since we start with 0-chunkSize for the range, we need to subtract 1.\n            var length = _this.totalChunks === 1 ? _this.file.size : _this.chunkByteSize;\n            var start = length * _this.chunkCount;\n            _this.reader.onload = function () {\n                if (_this.reader.result !== null) {\n                    _this.chunk = new Blob([_this.reader.result], {\n                        type: 'application/octet-stream',\n                    });\n                }\n                resolve();\n            };\n            _this.reader.readAsArrayBuffer(_this.file.slice(start, start + length));\n        });\n    };\n    /**\n     * Send chunk of the file with appropriate headers and add post parameters if it's last chunk\n     */\n    UpChunk.prototype.sendChunk = function () {\n        var rangeStart = this.chunkCount * this.chunkByteSize;\n        var rangeEnd = rangeStart + this.chunk.size - 1;\n        var headers = __assign({}, this.headers, { 'Content-Type': this.file.type, 'Content-Length': this.chunk.size, 'Content-Range': \"bytes \" + rangeStart + \"-\" + rangeEnd + \"/\" + this.file.size });\n        this.dispatch('attempt', {\n            chunkNumber: this.chunkCount,\n            chunkSize: this.chunk.size,\n        });\n        return fetch(this.endpointValue, {\n            headers: headers,\n            method: 'PUT',\n            body: this.chunk,\n        });\n    };\n    /**\n     * Called on net failure. If retry counter !== 0, retry after delayBeforeAttempt\n     */\n    UpChunk.prototype.manageRetries = function () {\n        var _this = this;\n        if (this.attemptCount < this.attempts) {\n            this.attemptCount = this.attemptCount + 1;\n            setTimeout(function () { return _this.sendChunks(); }, this.delayBeforeAttempt * 1000);\n            this.dispatch('attemptFailure', {\n                message: \"An error occured uploading chunk \" + this.chunkCount + \". \" + (this\n                    .attempts - this.attemptCount) + \" retries left.\",\n                chunkNumber: this.chunkCount,\n                attemptsLeft: this.attempts - this.attemptCount,\n            });\n            return;\n        }\n        this.dispatch('error', {\n            message: \"An error occured uploading chunk \" + this.chunkCount + \". No more retries, stopping upload\",\n            chunk: this.chunkCount,\n            attempts: this.attemptCount,\n        });\n    };\n    /**\n     * Manage the whole upload by calling getChunk & sendChunk\n     * handle errors & retries and dispatch events\n     */\n    UpChunk.prototype.sendChunks = function () {\n        var _this = this;\n        if (this.paused || this.offline) {\n            return;\n        }\n        this.getChunk()\n            .then(function () { return _this.sendChunk(); })\n            .then(function (res) {\n            if (SUCCESSFUL_CHUNK_UPLOAD_CODES.includes(res.status)) {\n                _this.chunkCount = _this.chunkCount + 1;\n                if (_this.chunkCount < _this.totalChunks) {\n                    _this.sendChunks();\n                }\n                else {\n                    _this.dispatch('success');\n                }\n                var percentProgress = Math.round((100 / _this.totalChunks) * _this.chunkCount);\n                _this.dispatch('progress', percentProgress);\n            }\n            else if (TEMPORARY_ERROR_CODES.includes(res.status)) {\n                if (_this.paused || _this.offline) {\n                    return;\n                }\n                _this.manageRetries();\n            }\n            else {\n                if (_this.paused || _this.offline) {\n                    return;\n                }\n                _this.dispatch('error', {\n                    message: \"Server responded with \" + res.status + \". Stopping upload.\",\n                    chunkNumber: _this.chunkCount,\n                    attempts: _this.attemptCount,\n                });\n            }\n        })[\"catch\"](function (err) {\n            if (_this.paused || _this.offline) {\n                return;\n            }\n            // this type of error can happen after network disconnection on CORS setup\n            _this.manageRetries();\n        });\n    };\n    return UpChunk;\n}());\nexports.UpChunk = UpChunk;\nexports.createUpload = function (options) { return new UpChunk(options); };\n","/**\n * @author Toru Nagashima <https://github.com/mysticatea>\n * @copyright 2015 Toru Nagashima. All rights reserved.\n * See LICENSE file in root directory for full license.\n */\n'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n/**\n * @typedef {object} PrivateData\n * @property {EventTarget} eventTarget The event target.\n * @property {{type:string}} event The original event object.\n * @property {number} eventPhase The current event phase.\n * @property {EventTarget|null} currentTarget The current event target.\n * @property {boolean} canceled The flag to prevent default.\n * @property {boolean} stopped The flag to stop propagation.\n * @property {boolean} immediateStopped The flag to stop propagation immediately.\n * @property {Function|null} passiveListener The listener if the current listener is passive. Otherwise this is null.\n * @property {number} timeStamp The unix time.\n * @private\n */\n\n/**\n * Private data for event wrappers.\n * @type {WeakMap<Event, PrivateData>}\n * @private\n */\nconst privateData = new WeakMap();\n\n/**\n * Cache for wrapper classes.\n * @type {WeakMap<Object, Function>}\n * @private\n */\nconst wrappers = new WeakMap();\n\n/**\n * Get private data.\n * @param {Event} event The event object to get private data.\n * @returns {PrivateData} The private data of the event.\n * @private\n */\nfunction pd(event) {\n    const retv = privateData.get(event);\n    console.assert(\n        retv != null,\n        \"'this' is expected an Event object, but got\",\n        event\n    );\n    return retv\n}\n\n/**\n * https://dom.spec.whatwg.org/#set-the-canceled-flag\n * @param data {PrivateData} private data.\n */\nfunction setCancelFlag(data) {\n    if (data.passiveListener != null) {\n        if (\n            typeof console !== \"undefined\" &&\n            typeof console.error === \"function\"\n        ) {\n            console.error(\n                \"Unable to preventDefault inside passive event listener invocation.\",\n                data.passiveListener\n            );\n        }\n        return\n    }\n    if (!data.event.cancelable) {\n        return\n    }\n\n    data.canceled = true;\n    if (typeof data.event.preventDefault === \"function\") {\n        data.event.preventDefault();\n    }\n}\n\n/**\n * @see https://dom.spec.whatwg.org/#interface-event\n * @private\n */\n/**\n * The event wrapper.\n * @constructor\n * @param {EventTarget} eventTarget The event target of this dispatching.\n * @param {Event|{type:string}} event The original event to wrap.\n */\nfunction Event(eventTarget, event) {\n    privateData.set(this, {\n        eventTarget,\n        event,\n        eventPhase: 2,\n        currentTarget: eventTarget,\n        canceled: false,\n        stopped: false,\n        immediateStopped: false,\n        passiveListener: null,\n        timeStamp: event.timeStamp || Date.now(),\n    });\n\n    // https://heycam.github.io/webidl/#Unforgeable\n    Object.defineProperty(this, \"isTrusted\", { value: false, enumerable: true });\n\n    // Define accessors\n    const keys = Object.keys(event);\n    for (let i = 0; i < keys.length; ++i) {\n        const key = keys[i];\n        if (!(key in this)) {\n            Object.defineProperty(this, key, defineRedirectDescriptor(key));\n        }\n    }\n}\n\n// Should be enumerable, but class methods are not enumerable.\nEvent.prototype = {\n    /**\n     * The type of this event.\n     * @type {string}\n     */\n    get type() {\n        return pd(this).event.type\n    },\n\n    /**\n     * The target of this event.\n     * @type {EventTarget}\n     */\n    get target() {\n        return pd(this).eventTarget\n    },\n\n    /**\n     * The target of this event.\n     * @type {EventTarget}\n     */\n    get currentTarget() {\n        return pd(this).currentTarget\n    },\n\n    /**\n     * @returns {EventTarget[]} The composed path of this event.\n     */\n    composedPath() {\n        const currentTarget = pd(this).currentTarget;\n        if (currentTarget == null) {\n            return []\n        }\n        return [currentTarget]\n    },\n\n    /**\n     * Constant of NONE.\n     * @type {number}\n     */\n    get NONE() {\n        return 0\n    },\n\n    /**\n     * Constant of CAPTURING_PHASE.\n     * @type {number}\n     */\n    get CAPTURING_PHASE() {\n        return 1\n    },\n\n    /**\n     * Constant of AT_TARGET.\n     * @type {number}\n     */\n    get AT_TARGET() {\n        return 2\n    },\n\n    /**\n     * Constant of BUBBLING_PHASE.\n     * @type {number}\n     */\n    get BUBBLING_PHASE() {\n        return 3\n    },\n\n    /**\n     * The target of this event.\n     * @type {number}\n     */\n    get eventPhase() {\n        return pd(this).eventPhase\n    },\n\n    /**\n     * Stop event bubbling.\n     * @returns {void}\n     */\n    stopPropagation() {\n        const data = pd(this);\n\n        data.stopped = true;\n        if (typeof data.event.stopPropagation === \"function\") {\n            data.event.stopPropagation();\n        }\n    },\n\n    /**\n     * Stop event bubbling.\n     * @returns {void}\n     */\n    stopImmediatePropagation() {\n        const data = pd(this);\n\n        data.stopped = true;\n        data.immediateStopped = true;\n        if (typeof data.event.stopImmediatePropagation === \"function\") {\n            data.event.stopImmediatePropagation();\n        }\n    },\n\n    /**\n     * The flag to be bubbling.\n     * @type {boolean}\n     */\n    get bubbles() {\n        return Boolean(pd(this).event.bubbles)\n    },\n\n    /**\n     * The flag to be cancelable.\n     * @type {boolean}\n     */\n    get cancelable() {\n        return Boolean(pd(this).event.cancelable)\n    },\n\n    /**\n     * Cancel this event.\n     * @returns {void}\n     */\n    preventDefault() {\n        setCancelFlag(pd(this));\n    },\n\n    /**\n     * The flag to indicate cancellation state.\n     * @type {boolean}\n     */\n    get defaultPrevented() {\n        return pd(this).canceled\n    },\n\n    /**\n     * The flag to be composed.\n     * @type {boolean}\n     */\n    get composed() {\n        return Boolean(pd(this).event.composed)\n    },\n\n    /**\n     * The unix time of this event.\n     * @type {number}\n     */\n    get timeStamp() {\n        return pd(this).timeStamp\n    },\n\n    /**\n     * The target of this event.\n     * @type {EventTarget}\n     * @deprecated\n     */\n    get srcElement() {\n        return pd(this).eventTarget\n    },\n\n    /**\n     * The flag to stop event bubbling.\n     * @type {boolean}\n     * @deprecated\n     */\n    get cancelBubble() {\n        return pd(this).stopped\n    },\n    set cancelBubble(value) {\n        if (!value) {\n            return\n        }\n        const data = pd(this);\n\n        data.stopped = true;\n        if (typeof data.event.cancelBubble === \"boolean\") {\n            data.event.cancelBubble = true;\n        }\n    },\n\n    /**\n     * The flag to indicate cancellation state.\n     * @type {boolean}\n     * @deprecated\n     */\n    get returnValue() {\n        return !pd(this).canceled\n    },\n    set returnValue(value) {\n        if (!value) {\n            setCancelFlag(pd(this));\n        }\n    },\n\n    /**\n     * Initialize this event object. But do nothing under event dispatching.\n     * @param {string} type The event type.\n     * @param {boolean} [bubbles=false] The flag to be possible to bubble up.\n     * @param {boolean} [cancelable=false] The flag to be possible to cancel.\n     * @deprecated\n     */\n    initEvent() {\n        // Do nothing.\n    },\n};\n\n// `constructor` is not enumerable.\nObject.defineProperty(Event.prototype, \"constructor\", {\n    value: Event,\n    configurable: true,\n    writable: true,\n});\n\n// Ensure `event instanceof window.Event` is `true`.\nif (typeof window !== \"undefined\" && typeof window.Event !== \"undefined\") {\n    Object.setPrototypeOf(Event.prototype, window.Event.prototype);\n\n    // Make association for wrappers.\n    wrappers.set(window.Event.prototype, Event);\n}\n\n/**\n * Get the property descriptor to redirect a given property.\n * @param {string} key Property name to define property descriptor.\n * @returns {PropertyDescriptor} The property descriptor to redirect the property.\n * @private\n */\nfunction defineRedirectDescriptor(key) {\n    return {\n        get() {\n            return pd(this).event[key]\n        },\n        set(value) {\n            pd(this).event[key] = value;\n        },\n        configurable: true,\n        enumerable: true,\n    }\n}\n\n/**\n * Get the property descriptor to call a given method property.\n * @param {string} key Property name to define property descriptor.\n * @returns {PropertyDescriptor} The property descriptor to call the method property.\n * @private\n */\nfunction defineCallDescriptor(key) {\n    return {\n        value() {\n            const event = pd(this).event;\n            return event[key].apply(event, arguments)\n        },\n        configurable: true,\n        enumerable: true,\n    }\n}\n\n/**\n * Define new wrapper class.\n * @param {Function} BaseEvent The base wrapper class.\n * @param {Object} proto The prototype of the original event.\n * @returns {Function} The defined wrapper class.\n * @private\n */\nfunction defineWrapper(BaseEvent, proto) {\n    const keys = Object.keys(proto);\n    if (keys.length === 0) {\n        return BaseEvent\n    }\n\n    /** CustomEvent */\n    function CustomEvent(eventTarget, event) {\n        BaseEvent.call(this, eventTarget, event);\n    }\n\n    CustomEvent.prototype = Object.create(BaseEvent.prototype, {\n        constructor: { value: CustomEvent, configurable: true, writable: true },\n    });\n\n    // Define accessors.\n    for (let i = 0; i < keys.length; ++i) {\n        const key = keys[i];\n        if (!(key in BaseEvent.prototype)) {\n            const descriptor = Object.getOwnPropertyDescriptor(proto, key);\n            const isFunc = typeof descriptor.value === \"function\";\n            Object.defineProperty(\n                CustomEvent.prototype,\n                key,\n                isFunc\n                    ? defineCallDescriptor(key)\n                    : defineRedirectDescriptor(key)\n            );\n        }\n    }\n\n    return CustomEvent\n}\n\n/**\n * Get the wrapper class of a given prototype.\n * @param {Object} proto The prototype of the original event to get its wrapper.\n * @returns {Function} The wrapper class.\n * @private\n */\nfunction getWrapper(proto) {\n    if (proto == null || proto === Object.prototype) {\n        return Event\n    }\n\n    let wrapper = wrappers.get(proto);\n    if (wrapper == null) {\n        wrapper = defineWrapper(getWrapper(Object.getPrototypeOf(proto)), proto);\n        wrappers.set(proto, wrapper);\n    }\n    return wrapper\n}\n\n/**\n * Wrap a given event to management a dispatching.\n * @param {EventTarget} eventTarget The event target of this dispatching.\n * @param {Object} event The event to wrap.\n * @returns {Event} The wrapper instance.\n * @private\n */\nfunction wrapEvent(eventTarget, event) {\n    const Wrapper = getWrapper(Object.getPrototypeOf(event));\n    return new Wrapper(eventTarget, event)\n}\n\n/**\n * Get the immediateStopped flag of a given event.\n * @param {Event} event The event to get.\n * @returns {boolean} The flag to stop propagation immediately.\n * @private\n */\nfunction isStopped(event) {\n    return pd(event).immediateStopped\n}\n\n/**\n * Set the current event phase of a given event.\n * @param {Event} event The event to set current target.\n * @param {number} eventPhase New event phase.\n * @returns {void}\n * @private\n */\nfunction setEventPhase(event, eventPhase) {\n    pd(event).eventPhase = eventPhase;\n}\n\n/**\n * Set the current target of a given event.\n * @param {Event} event The event to set current target.\n * @param {EventTarget|null} currentTarget New current target.\n * @returns {void}\n * @private\n */\nfunction setCurrentTarget(event, currentTarget) {\n    pd(event).currentTarget = currentTarget;\n}\n\n/**\n * Set a passive listener of a given event.\n * @param {Event} event The event to set current target.\n * @param {Function|null} passiveListener New passive listener.\n * @returns {void}\n * @private\n */\nfunction setPassiveListener(event, passiveListener) {\n    pd(event).passiveListener = passiveListener;\n}\n\n/**\n * @typedef {object} ListenerNode\n * @property {Function} listener\n * @property {1|2|3} listenerType\n * @property {boolean} passive\n * @property {boolean} once\n * @property {ListenerNode|null} next\n * @private\n */\n\n/**\n * @type {WeakMap<object, Map<string, ListenerNode>>}\n * @private\n */\nconst listenersMap = new WeakMap();\n\n// Listener types\nconst CAPTURE = 1;\nconst BUBBLE = 2;\nconst ATTRIBUTE = 3;\n\n/**\n * Check whether a given value is an object or not.\n * @param {any} x The value to check.\n * @returns {boolean} `true` if the value is an object.\n */\nfunction isObject(x) {\n    return x !== null && typeof x === \"object\" //eslint-disable-line no-restricted-syntax\n}\n\n/**\n * Get listeners.\n * @param {EventTarget} eventTarget The event target to get.\n * @returns {Map<string, ListenerNode>} The listeners.\n * @private\n */\nfunction getListeners(eventTarget) {\n    const listeners = listenersMap.get(eventTarget);\n    if (listeners == null) {\n        throw new TypeError(\n            \"'this' is expected an EventTarget object, but got another value.\"\n        )\n    }\n    return listeners\n}\n\n/**\n * Get the property descriptor for the event attribute of a given event.\n * @param {string} eventName The event name to get property descriptor.\n * @returns {PropertyDescriptor} The property descriptor.\n * @private\n */\nfunction defineEventAttributeDescriptor(eventName) {\n    return {\n        get() {\n            const listeners = getListeners(this);\n            let node = listeners.get(eventName);\n            while (node != null) {\n                if (node.listenerType === ATTRIBUTE) {\n                    return node.listener\n                }\n                node = node.next;\n            }\n            return null\n        },\n\n        set(listener) {\n            if (typeof listener !== \"function\" && !isObject(listener)) {\n                listener = null; // eslint-disable-line no-param-reassign\n            }\n            const listeners = getListeners(this);\n\n            // Traverse to the tail while removing old value.\n            let prev = null;\n            let node = listeners.get(eventName);\n            while (node != null) {\n                if (node.listenerType === ATTRIBUTE) {\n                    // Remove old value.\n                    if (prev !== null) {\n                        prev.next = node.next;\n                    } else if (node.next !== null) {\n                        listeners.set(eventName, node.next);\n                    } else {\n                        listeners.delete(eventName);\n                    }\n                } else {\n                    prev = node;\n                }\n\n                node = node.next;\n            }\n\n            // Add new value.\n            if (listener !== null) {\n                const newNode = {\n                    listener,\n                    listenerType: ATTRIBUTE,\n                    passive: false,\n                    once: false,\n                    next: null,\n                };\n                if (prev === null) {\n                    listeners.set(eventName, newNode);\n                } else {\n                    prev.next = newNode;\n                }\n            }\n        },\n        configurable: true,\n        enumerable: true,\n    }\n}\n\n/**\n * Define an event attribute (e.g. `eventTarget.onclick`).\n * @param {Object} eventTargetPrototype The event target prototype to define an event attrbite.\n * @param {string} eventName The event name to define.\n * @returns {void}\n */\nfunction defineEventAttribute(eventTargetPrototype, eventName) {\n    Object.defineProperty(\n        eventTargetPrototype,\n        `on${eventName}`,\n        defineEventAttributeDescriptor(eventName)\n    );\n}\n\n/**\n * Define a custom EventTarget with event attributes.\n * @param {string[]} eventNames Event names for event attributes.\n * @returns {EventTarget} The custom EventTarget.\n * @private\n */\nfunction defineCustomEventTarget(eventNames) {\n    /** CustomEventTarget */\n    function CustomEventTarget() {\n        EventTarget.call(this);\n    }\n\n    CustomEventTarget.prototype = Object.create(EventTarget.prototype, {\n        constructor: {\n            value: CustomEventTarget,\n            configurable: true,\n            writable: true,\n        },\n    });\n\n    for (let i = 0; i < eventNames.length; ++i) {\n        defineEventAttribute(CustomEventTarget.prototype, eventNames[i]);\n    }\n\n    return CustomEventTarget\n}\n\n/**\n * EventTarget.\n *\n * - This is constructor if no arguments.\n * - This is a function which returns a CustomEventTarget constructor if there are arguments.\n *\n * For example:\n *\n *     class A extends EventTarget {}\n *     class B extends EventTarget(\"message\") {}\n *     class C extends EventTarget(\"message\", \"error\") {}\n *     class D extends EventTarget([\"message\", \"error\"]) {}\n */\nfunction EventTarget() {\n    /*eslint-disable consistent-return */\n    if (this instanceof EventTarget) {\n        listenersMap.set(this, new Map());\n        return\n    }\n    if (arguments.length === 1 && Array.isArray(arguments[0])) {\n        return defineCustomEventTarget(arguments[0])\n    }\n    if (arguments.length > 0) {\n        const types = new Array(arguments.length);\n        for (let i = 0; i < arguments.length; ++i) {\n            types[i] = arguments[i];\n        }\n        return defineCustomEventTarget(types)\n    }\n    throw new TypeError(\"Cannot call a class as a function\")\n    /*eslint-enable consistent-return */\n}\n\n// Should be enumerable, but class methods are not enumerable.\nEventTarget.prototype = {\n    /**\n     * Add a given listener to this event target.\n     * @param {string} eventName The event name to add.\n     * @param {Function} listener The listener to add.\n     * @param {boolean|{capture?:boolean,passive?:boolean,once?:boolean}} [options] The options for this listener.\n     * @returns {void}\n     */\n    addEventListener(eventName, listener, options) {\n        if (listener == null) {\n            return\n        }\n        if (typeof listener !== \"function\" && !isObject(listener)) {\n            throw new TypeError(\"'listener' should be a function or an object.\")\n        }\n\n        const listeners = getListeners(this);\n        const optionsIsObj = isObject(options);\n        const capture = optionsIsObj\n            ? Boolean(options.capture)\n            : Boolean(options);\n        const listenerType = capture ? CAPTURE : BUBBLE;\n        const newNode = {\n            listener,\n            listenerType,\n            passive: optionsIsObj && Boolean(options.passive),\n            once: optionsIsObj && Boolean(options.once),\n            next: null,\n        };\n\n        // Set it as the first node if the first node is null.\n        let node = listeners.get(eventName);\n        if (node === undefined) {\n            listeners.set(eventName, newNode);\n            return\n        }\n\n        // Traverse to the tail while checking duplication..\n        let prev = null;\n        while (node != null) {\n            if (\n                node.listener === listener &&\n                node.listenerType === listenerType\n            ) {\n                // Should ignore duplication.\n                return\n            }\n            prev = node;\n            node = node.next;\n        }\n\n        // Add it.\n        prev.next = newNode;\n    },\n\n    /**\n     * Remove a given listener from this event target.\n     * @param {string} eventName The event name to remove.\n     * @param {Function} listener The listener to remove.\n     * @param {boolean|{capture?:boolean,passive?:boolean,once?:boolean}} [options] The options for this listener.\n     * @returns {void}\n     */\n    removeEventListener(eventName, listener, options) {\n        if (listener == null) {\n            return\n        }\n\n        const listeners = getListeners(this);\n        const capture = isObject(options)\n            ? Boolean(options.capture)\n            : Boolean(options);\n        const listenerType = capture ? CAPTURE : BUBBLE;\n\n        let prev = null;\n        let node = listeners.get(eventName);\n        while (node != null) {\n            if (\n                node.listener === listener &&\n                node.listenerType === listenerType\n            ) {\n                if (prev !== null) {\n                    prev.next = node.next;\n                } else if (node.next !== null) {\n                    listeners.set(eventName, node.next);\n                } else {\n                    listeners.delete(eventName);\n                }\n                return\n            }\n\n            prev = node;\n            node = node.next;\n        }\n    },\n\n    /**\n     * Dispatch a given event.\n     * @param {Event|{type:string}} event The event to dispatch.\n     * @returns {boolean} `false` if canceled.\n     */\n    dispatchEvent(event) {\n        if (event == null || typeof event.type !== \"string\") {\n            throw new TypeError('\"event.type\" should be a string.')\n        }\n\n        // If listeners aren't registered, terminate.\n        const listeners = getListeners(this);\n        const eventName = event.type;\n        let node = listeners.get(eventName);\n        if (node == null) {\n            return true\n        }\n\n        // Since we cannot rewrite several properties, so wrap object.\n        const wrappedEvent = wrapEvent(this, event);\n\n        // This doesn't process capturing phase and bubbling phase.\n        // This isn't participating in a tree.\n        let prev = null;\n        while (node != null) {\n            // Remove this listener if it's once\n            if (node.once) {\n                if (prev !== null) {\n                    prev.next = node.next;\n                } else if (node.next !== null) {\n                    listeners.set(eventName, node.next);\n                } else {\n                    listeners.delete(eventName);\n                }\n            } else {\n                prev = node;\n            }\n\n            // Call this listener\n            setPassiveListener(\n                wrappedEvent,\n                node.passive ? node.listener : null\n            );\n            if (typeof node.listener === \"function\") {\n                try {\n                    node.listener.call(this, wrappedEvent);\n                } catch (err) {\n                    if (\n                        typeof console !== \"undefined\" &&\n                        typeof console.error === \"function\"\n                    ) {\n                        console.error(err);\n                    }\n                }\n            } else if (\n                node.listenerType !== ATTRIBUTE &&\n                typeof node.listener.handleEvent === \"function\"\n            ) {\n                node.listener.handleEvent(wrappedEvent);\n            }\n\n            // Break if `event.stopImmediatePropagation` was called.\n            if (isStopped(wrappedEvent)) {\n                break\n            }\n\n            node = node.next;\n        }\n        setPassiveListener(wrappedEvent, null);\n        setEventPhase(wrappedEvent, 0);\n        setCurrentTarget(wrappedEvent, null);\n\n        return !wrappedEvent.defaultPrevented\n    },\n};\n\n// `constructor` is not enumerable.\nObject.defineProperty(EventTarget.prototype, \"constructor\", {\n    value: EventTarget,\n    configurable: true,\n    writable: true,\n});\n\n// Ensure `eventTarget instanceof window.EventTarget` is `true`.\nif (\n    typeof window !== \"undefined\" &&\n    typeof window.EventTarget !== \"undefined\"\n) {\n    Object.setPrototypeOf(EventTarget.prototype, window.EventTarget.prototype);\n}\n\nexports.defineEventAttribute = defineEventAttribute;\nexports.EventTarget = EventTarget;\nexports.default = EventTarget;\n\nmodule.exports = EventTarget\nmodule.exports.EventTarget = module.exports[\"default\"] = EventTarget\nmodule.exports.defineEventAttribute = defineEventAttribute\n//# sourceMappingURL=event-target-shim.js.map\n"],"sourceRoot":""}