declare type EventName = 'attempt' | 'attemptFailure' | 'error' | 'offline' | 'online' | 'progress' | 'success';
interface IOptions {
    endpoint: string | ((file?: File) => Promise<string>);
    file: File;
    headers?: Headers;
    chunkSize?: number;
    attempts?: number;
    delayBeforeAttempt?: number;
}
export declare class UpChunk {
    endpoint: string | ((file?: File) => Promise<string>);
    file: File;
    headers: Headers;
    chunkSize: number;
    attempts: number;
    delayBeforeAttempt: number;
    private chunk;
    private chunkCount;
    private chunkByteSize;
    private endpointValue;
    private totalChunks;
    private attemptCount;
    private offline;
    private paused;
    private reader;
    private eventTarget;
    constructor(options: IOptions);
    /**
     * Subscribe to an event
     */
    on(eventName: EventName, fn: (event: CustomEvent) => void): void;
    pause(): void;
    resume(): void;
    /**
     * Dispatch an event
     */
    private dispatch;
    /**
     * Validate options and throw error if not of the right type
     */
    private validateOptions;
    /**
     * Endpoint can either be a URL or a function that returns a promise that resolves to a string.
     */
    private getEndpoint;
    /**
     * Get portion of the file of x bytes corresponding to chunkSize
     */
    private getChunk;
    /**
     * Send chunk of the file with appropriate headers and add post parameters if it's last chunk
     */
    private sendChunk;
    /**
     * Called on net failure. If retry counter !== 0, retry after delayBeforeAttempt
     */
    private manageRetries;
    /**
     * Manage the whole upload by calling getChunk & sendChunk
     * handle errors & retries and dispatch events
     */
    private sendChunks;
}
export declare const createUpload: (options: IOptions) => UpChunk;
export {};
